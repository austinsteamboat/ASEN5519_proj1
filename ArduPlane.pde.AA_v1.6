/// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

#define THISFIRMWARE "ArduPlane CU v1.6 V3.1.2beta1"
/*
   Lead developer: Andrew Tridgell
 
   Authors:    Doug Weibel, Jose Julio, Jordi Munoz, Jason Short, Randy Mackay, Pat Hickey, John Arne Birkeland, Olivier Adler, Amilcar Lucas, Gregory Fletcher, Paul Riseborough, Brandon Jones, Jon Challinger
   Thanks to:  Chris Anderson, Michael Oborne, Paul Mather, Bill Premerlani, James Cohen, JB from rotorFX, Automatik, Fefenin, Peter Meister, Remzibi, Yury Smirnov, Sandro Benigno, Max Levine, Roberto Navoni, Lorenz Meier, Yury MonZon

   Please contribute your ideas! See http://dev.ardupilot.com for details

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

////////////////////////////////////////////////////////////////////////////////
// Header includes
////////////////////////////////////////////////////////////////////////////////

#include <math.h>
#include <stdarg.h>
#include <stdio.h>
// Begin ASEN5519 Includes
#include "stdlib.h"
#include "f_frew.h"
// End ASEN519 Includes
#include <AP_HAL.h>
#include <AP_Common.h>
#include <AP_Progmem.h>
#include <AP_Menu.h>
#include <AP_Param.h>
#include <StorageManager.h>
#include <AP_GPS.h>         // ArduPilot GPS library
#include <AP_Baro.h>        // ArduPilot barometer library
#include <AP_Compass.h>     // ArduPilot Mega Magnetometer Library
#include <AP_Math.h>        // ArduPilot Mega Vector/Matrix math Library
#include <AP_ADC.h>         // ArduPilot Mega Analog to Digital Converter Library
#include <AP_ADC_AnalogSource.h>
#include <AP_InertialSensor.h> // Inertial Sensor Library
#include <AP_AHRS.h>         // ArduPilot Mega DCM Library
#include <RC_Channel.h>     // RC Channel Library
#include <AP_RangeFinder.h>     // Range finder library
#include <Filter.h>                     // Filter library
#include <AP_Buffer.h>      // APM FIFO Buffer
#include <AP_Relay.h>       // APM relay
#include <AP_Camera.h>          // Photo or video camera
#include <AP_Airspeed.h>
#include <AP_Terrain.h>

#include <APM_OBC.h>
#include <APM_Control.h>
#include <AP_AutoTune.h>
#include <GCS.h>
#include <GCS_MAVLink.h>    // MAVLink GCS definitions
#include <AP_Mount.h>           // Camera/Antenna mount
#include <AP_Declination.h> // ArduPilot Mega Declination Helper Library
#include <DataFlash.h>
#include <SITL.h>
#include <AP_Scheduler.h>       // main loop scheduler

#include <AP_Navigation.h>
#include <AP_L1_Control.h>
#include <AP_RCMapper.h>        // RC input mapping library

#include <AP_Vehicle.h>
#include <AP_SpdHgtControl.h>
#include <AP_TECS.h>
#include <AP_NavEKF.h>
#include <AP_Mission.h>     // Mission command library

#include <AP_Notify.h>      // Notify library
#include <AP_BattMonitor.h> // Battery monitor library

#include <AP_Arming.h>
#include <AP_BoardConfig.h>
#include <AP_Frsky_Telem.h>
#include <AP_ServoRelayEvents.h>

#include <AP_Rally.h>

// Pre-AP_HAL compatibility
#include "compat.h"

// Configuration
#include "config.h"

// Local modules
#include "defines.h"

// key aircraft parameters passed to multiple libraries
static AP_Vehicle::FixedWing aparm;

#include "Parameters.h"

#include <AP_HAL_AVR.h>
#include <AP_HAL_AVR_SITL.h>
#include <AP_HAL_PX4.h>
#include <AP_HAL_FLYMAPLE.h>
#include <AP_HAL_Linux.h> 
#include <AP_HAL_Empty.h>
#include <AP_HAL_VRBRAIN.h>

// ASEN5519 Defines -> Check if these are made elsewhere
#define PI_CU 3.141592653589793 // pi
#define r_earth_CU 6371000 // earth radius
#define deg_val_CU 0.005555555556 // 1/180
#define GRAV_CU 9.81
// End ASEN5519 Defines

AP_HAL::BetterStream* cliSerial;

const AP_HAL::HAL& hal = AP_HAL_BOARD_DRIVER;


////////////////////////////////////////////////////////////////////////////////
// the rate we run the main loop at
////////////////////////////////////////////////////////////////////////////////
static const AP_InertialSensor::Sample_rate ins_sample_rate = AP_InertialSensor::RATE_50HZ;

////////////////////////////////////////////////////////////////////////////////
// Parameters
////////////////////////////////////////////////////////////////////////////////
//
// Global parameters are all contained within the 'g' class.
//
static Parameters g;

// main loop scheduler
static AP_Scheduler scheduler;
 
// mapping between input channels
static RCMapper rcmap;

// board specific config
static AP_BoardConfig BoardConfig;

// primary control channels
static RC_Channel *channel_roll;
static RC_Channel *channel_pitch;
static RC_Channel *channel_throttle;
static RC_Channel *channel_rudder;

// notification object for LEDs, buzzers etc (parameter set to false disables external leds)
static AP_Notify notify;

////////////////////////////////////////////////////////////////////////////////
// prototypes
static void update_events(void);
void gcs_send_text_fmt(const prog_char_t *fmt, ...);
static void print_flight_mode(AP_HAL::BetterStream *port, uint8_t mode);

////////////////////////////////////////////////////////////////////////////////
// DataFlash
////////////////////////////////////////////////////////////////////////////////
#if LOGGING_ENABLED == ENABLED
#if CONFIG_HAL_BOARD == HAL_BOARD_APM1
static DataFlash_APM1 DataFlash;
#elif CONFIG_HAL_BOARD == HAL_BOARD_APM2
static DataFlash_APM2 DataFlash;
#elif defined(HAL_BOARD_LOG_DIRECTORY)
static DataFlash_File DataFlash(HAL_BOARD_LOG_DIRECTORY);
#else
// no dataflash driver
DataFlash_Empty DataFlash;
#endif
#endif

// has a log download started?
static bool in_log_download;

// scaled roll limit based on pitch
static int32_t roll_limit_cd;
static int32_t pitch_limit_min_cd;

////////////////////////////////////////////////////////////////////////////////
// Sensors
////////////////////////////////////////////////////////////////////////////////
//
// There are three basic options related to flight sensor selection.
//
// - Normal flight mode.  Real sensors are used.
// - HIL Attitude mode.  Most sensors are disabled, as the HIL
//   protocol supplies attitude information directly.
// - HIL Sensors mode.  Synthetic sensors are configured that
//   supply data from the simulation.
//

// GPS driver
static AP_GPS gps;

// flight modes convenience array
static AP_Int8          *flight_modes = &g.flight_mode1;

#if CONFIG_BARO == HAL_BARO_BMP085
static AP_Baro_BMP085 barometer;
#elif CONFIG_BARO == HAL_BARO_PX4
static AP_Baro_PX4 barometer;
#elif CONFIG_BARO == HAL_BARO_VRBRAIN
static AP_Baro_VRBRAIN barometer;
#elif CONFIG_BARO == HAL_BARO_HIL
static AP_Baro_HIL barometer;
#elif CONFIG_BARO == HAL_BARO_MS5611
static AP_Baro_MS5611 barometer(&AP_Baro_MS5611::i2c);
#elif CONFIG_BARO == HAL_BARO_MS5611_SPI
static AP_Baro_MS5611 barometer(&AP_Baro_MS5611::spi);
#else
 #error Unrecognized CONFIG_BARO setting
#endif

#if CONFIG_COMPASS == HAL_COMPASS_PX4
static AP_Compass_PX4 compass;
#elif CONFIG_COMPASS == HAL_COMPASS_VRBRAIN
static AP_Compass_VRBRAIN compass;
#elif CONFIG_COMPASS == HAL_COMPASS_HMC5843
static AP_Compass_HMC5843 compass;
#elif CONFIG_COMPASS == HAL_COMPASS_HIL
static AP_Compass_HIL compass;
#else
 #error Unrecognized CONFIG_COMPASS setting
#endif

#if CONFIG_INS_TYPE == HAL_INS_OILPAN || CONFIG_HAL_BOARD == HAL_BOARD_APM1
AP_ADC_ADS7844 apm1_adc;
#endif

#if CONFIG_INS_TYPE == HAL_INS_MPU6000
AP_InertialSensor_MPU6000 ins;
#elif CONFIG_INS_TYPE == HAL_INS_PX4
AP_InertialSensor_PX4 ins;
#elif CONFIG_INS_TYPE == HAL_INS_VRBRAIN
AP_InertialSensor_VRBRAIN ins;
#elif CONFIG_INS_TYPE == HAL_INS_HIL
AP_InertialSensor_HIL ins;
#elif CONFIG_INS_TYPE == HAL_INS_OILPAN
AP_InertialSensor_Oilpan ins( &apm1_adc );
#elif CONFIG_INS_TYPE == HAL_INS_FLYMAPLE
AP_InertialSensor_Flymaple ins;
#elif CONFIG_INS_TYPE == HAL_INS_L3G4200D
AP_InertialSensor_L3G4200D ins;
#elif CONFIG_INS_TYPE == HAL_INS_MPU9250
AP_InertialSensor_MPU9250 ins;
#else
  #error Unrecognised CONFIG_INS_TYPE setting.
#endif // CONFIG_INS_TYPE

// Inertial Navigation EKF
#if AP_AHRS_NAVEKF_AVAILABLE
AP_AHRS_NavEKF ahrs(ins, barometer, gps);
#else
AP_AHRS_DCM ahrs(ins, barometer, gps);
#endif

// ASEN5519 statics:
static int count_val = 0;
static double alt_origin = 584;
static double lat_origin = -35.363261;
static double lon_origin = 149.165230;
static double Cur_NED_pos[3] = {0}; 
static double Old_NED_pos[3] = {0}; 
static float frew_alg_com[3] = {0};
static float frew_alg_com_old[3] = {0};
static float temp_pitch = 0;
static float temp_roll = 0;
static float cur_course = 0;
// End ASEN5519 Statics

static AP_L1_Control L1_controller(ahrs);
static AP_TECS TECS_controller(ahrs, aparm);

// Attitude to servo controllers
static AP_RollController  rollController(ahrs, aparm, DataFlash);
static AP_PitchController pitchController(ahrs, aparm, DataFlash);
static AP_YawController   yawController(ahrs, aparm);
static AP_SteerController steerController(ahrs);

#if CONFIG_HAL_BOARD == HAL_BOARD_AVR_SITL
SITL sitl;
#endif

// Training mode
static bool training_manual_roll;  // user has manual roll control
static bool training_manual_pitch; // user has manual pitch control

/*
  keep steering and rudder control separated until we update servos,
  to allow for a separate wheel servo from rudder servo
 */
static struct {
    bool ground_steering; // are we doing ground steering?
    int16_t steering; // value for nose/tail wheel
    int16_t rudder;   // value for rudder
} steering_control;

// should throttle be pass-thru in guided?
static bool guided_throttle_passthru;

// are we doing calibration? This is used to allow heartbeat to
// external failsafe boards during baro and airspeed calibration
static bool in_calibration;


////////////////////////////////////////////////////////////////////////////////
// GCS selection
////////////////////////////////////////////////////////////////////////////////
static const uint8_t num_gcs = MAVLINK_COMM_NUM_BUFFERS;
static GCS_MAVLINK gcs[MAVLINK_COMM_NUM_BUFFERS];

// selected navigation controller
static AP_Navigation *nav_controller = &L1_controller;

// selected navigation controller
static AP_SpdHgtControl *SpdHgt_Controller = &TECS_controller;

////////////////////////////////////////////////////////////////////////////////
// Analog Inputs
////////////////////////////////////////////////////////////////////////////////

// a pin for reading the receiver RSSI voltage. 
static AP_HAL::AnalogSource *rssi_analog_source;

////////////////////////////////////////////////////////////////////////////////
// rangefinder
////////////////////////////////////////////////////////////////////////////////
static RangeFinder rangefinder;

static struct {
    bool in_range;
    float correction;
    uint32_t last_correction_time_ms;
    uint8_t in_range_count;
} rangefinder_state;

////////////////////////////////////////////////////////////////////////////////
// Relay
////////////////////////////////////////////////////////////////////////////////
static AP_Relay relay;

// handle servo and relay events
static AP_ServoRelayEvents ServoRelayEvents(relay);

// Camera
#if CAMERA == ENABLED
static AP_Camera camera(&relay);
#endif

//Rally Ponints
AP_Rally rally(ahrs);

////////////////////////////////////////////////////////////////////////////////
// Global variables
////////////////////////////////////////////////////////////////////////////////

// remember if USB is connected, so we can adjust baud rate
static bool usb_connected;

/* Radio values
 *               Channel assignments
 *                       1   Ailerons
 *                       2   Elevator
 *                       3   Throttle
 *                       4   Rudder
 *                       5   Aux5
 *                       6   Aux6
 *                       7   Aux7
 *                       8   Aux8/Mode
 *               Each Aux channel can be configured to have any of the available auxiliary functions assigned to it.
 *               See libraries/RC_Channel/RC_Channel_aux.h for more information
 */

////////////////////////////////////////////////////////////////////////////////
// Radio
////////////////////////////////////////////////////////////////////////////////
// This is the state of the flight control system
// There are multiple states defined such as MANUAL, FBW-A, AUTO
static enum FlightMode control_mode  = INITIALISING;
static enum FlightMode previous_mode = INITIALISING;

// Used to maintain the state of the previous control switch position
// This is set to 254 when we need to re-read the switch
static uint8_t oldSwitchPosition = 254;

// This is used to enable the inverted flight feature
static bool inverted_flight     = false;

static struct {
    // These are trim values used for elevon control
    // For elevons radio_in[CH_ROLL] and radio_in[CH_PITCH] are
    // equivalent aileron and elevator, not left and right elevon
    uint16_t trim1;
    uint16_t trim2;
    // These are used in the calculation of elevon1_trim and elevon2_trim
    uint16_t ch1_temp;
    uint16_t ch2_temp;
} elevon = {
	trim1 : 1500,
    trim2 : 1500,
    ch1_temp : 1500,
    ch2_temp : 1500
};


////////////////////////////////////////////////////////////////////////////////
// Failsafe
////////////////////////////////////////////////////////////////////////////////
static struct {
    // A flag if GCS joystick control is in use
    uint8_t rc_override_active:1;

    // Used to track if the value on channel 3 (throtttle) has fallen below the failsafe threshold
    // RC receiver should be set up to output a low throttle value when signal is lost
    uint8_t ch3_failsafe:1;

    // has the saved mode for failsafe been set?
    uint8_t saved_mode_set:1;

    // flag to hold whether battery low voltage threshold has been breached
    uint8_t low_battery:1;

    // saved flight mode
    enum FlightMode saved_mode;

    // A tracking variable for type of failsafe active
    // Used for failsafe based on loss of RC signal or GCS signal
    int16_t state;

    // number of low ch3 values
    uint8_t ch3_counter;

    // the time when the last HEARTBEAT message arrived from a GCS
    uint32_t last_heartbeat_ms;

    // A timer used to track how long we have been in a "short failsafe" condition due to loss of RC signal
    uint32_t ch3_timer_ms;

    uint32_t last_valid_rc_ms;
} failsafe;


////////////////////////////////////////////////////////////////////////////////
// GPS variables
////////////////////////////////////////////////////////////////////////////////
// This is used to scale GPS values for EEPROM storage
// 10^7 times Decimal GPS means 1 == 1cm
// This approximation makes calculations integer and it's easy to read
static const float t7                        = 10000000.0;
// We use atan2 and other trig techniques to calaculate angles
// A counter used to count down valid gps fixes to allow the gps estimate to settle
// before recording our home position (and executing a ground start if we booted with an air start)
static uint8_t ground_start_count      = 5;

// true if we have a position estimate from AHRS
static bool have_position;


////////////////////////////////////////////////////////////////////////////////
// Airspeed
////////////////////////////////////////////////////////////////////////////////
// The calculated airspeed to use in FBW-B.  Also used in higher modes for insuring min ground speed is met.
// Also used for flap deployment criteria.  Centimeters per second.
static int32_t target_airspeed_cm;

// The difference between current and desired airspeed.  Used in the pitch controller.  Centimeters per second.
static float airspeed_error_cm;

// An amount that the airspeed should be increased in auto modes based on the user positioning the
// throttle stick in the top half of the range.  Centimeters per second.
static int16_t airspeed_nudge_cm;

// Similar to airspeed_nudge, but used when no airspeed sensor.
// 0-(throttle_max - throttle_cruise) : throttle nudge in Auto mode using top 1/2 of throttle stick travel
static int16_t throttle_nudge = 0;

// receiver RSSI
static uint8_t receiver_rssi;


////////////////////////////////////////////////////////////////////////////////
// Ground speed
////////////////////////////////////////////////////////////////////////////////
// The amount current ground speed is below min ground speed.  Centimeters per second
static int32_t groundspeed_undershoot = 0;

// Difference between current altitude and desired altitude.  Centimeters
static int32_t altitude_error_cm;

////////////////////////////////////////////////////////////////////////////////
// Battery Sensors
////////////////////////////////////////////////////////////////////////////////
static AP_BattMonitor battery;

////////////////////////////////////////////////////////////////////////////////
// FrSky telemetry support
#if FRSKY_TELEM_ENABLED == ENABLED
static AP_Frsky_Telem frsky_telemetry(ahrs, battery);
#endif

////////////////////////////////////////////////////////////////////////////////
// Airspeed Sensors
////////////////////////////////////////////////////////////////////////////////
AP_Airspeed airspeed(aparm);

////////////////////////////////////////////////////////////////////////////////
// ACRO controller state
////////////////////////////////////////////////////////////////////////////////
static struct {
    bool locked_roll;
    bool locked_pitch;
    float locked_roll_err;
    int32_t locked_pitch_cd;
} acro_state;

////////////////////////////////////////////////////////////////////////////////
// CRUISE controller state
////////////////////////////////////////////////////////////////////////////////
static struct {
    bool locked_heading;
    int32_t locked_heading_cd;
    uint32_t lock_timer_ms;
} cruise_state;

////////////////////////////////////////////////////////////////////////////////
// ground steering controller state
////////////////////////////////////////////////////////////////////////////////
static struct {
	// Direction held during phases of takeoff and landing centidegrees
	// A value of -1 indicates the course has not been set/is not in use
	// this is a 0..36000 value, or -1 for disabled
    int32_t hold_course_cd;

    // locked_course and locked_course_cd are used in stabilize mode 
    // when ground steering is active, and for steering in auto-takeoff
    bool locked_course;
    float locked_course_err;
} steer_state = {
	hold_course_cd    : -1,
    locked_course     : false,
    locked_course_err : 0
};

////////////////////////////////////////////////////////////////////////////////
// flight mode specific
////////////////////////////////////////////////////////////////////////////////
static struct {
    // Flag for using gps ground course instead of INS yaw.  Set false when takeoff command in process.
    bool takeoff_complete:1;

    // Flag to indicate if we have landed.
    // Set land_complete if we are within 2 seconds distance or within 3 meters altitude of touchdown
    bool land_complete:1;

    // should we fly inverted?
    bool inverted_flight:1;

    // should we disable cross-tracking for the next waypoint?
    bool next_wp_no_crosstrack:1;

    // should we use cross-tracking for this waypoint?
    bool no_crosstrack:1;

    // in FBWA taildragger takeoff mode
    bool fbwa_tdrag_takeoff_mode:1;

    // Altitude threshold to complete a takeoff command in autonomous modes.  Centimeters
    int32_t takeoff_altitude_cm;

    // Minimum pitch to hold during takeoff command execution.  Hundredths of a degree
    int16_t takeoff_pitch_cd;

    // the highest airspeed we have reached since entering AUTO. Used
    // to control ground takeoff
    float highest_airspeed;

    // initial pitch. Used to detect if nose is rising in a tail dragger
    int16_t initial_pitch_cd;

    // turn angle for next leg of mission
    float next_turn_angle;

    // filtered sink rate for landing
    float land_sink_rate;

    // time when we first pass min GPS speed on takeoff
    uint32_t takeoff_speed_time_ms;
} auto_state = {
    takeoff_complete : true,
    land_complete : false,
    inverted_flight  : false,
    next_wp_no_crosstrack : true,
    no_crosstrack : true,
    fbwa_tdrag_takeoff_mode : false,
    takeoff_altitude_cm : 0,
    takeoff_pitch_cd : 0,
    highest_airspeed : 0,
    initial_pitch_cd : 0,
    next_turn_angle  : 90.0f,
    land_sink_rate   : 0,
    takeoff_speed_time_ms : 0
};

// true if we are in an auto-throttle mode, which means
// we need to run the speed/height controller
static bool auto_throttle_mode;

// this controls throttle suppression in auto modes
static bool throttle_suppressed;

AP_SpdHgtControl::FlightStage flight_stage = AP_SpdHgtControl::FLIGHT_NORMAL;

////////////////////////////////////////////////////////////////////////////////
// Loiter management
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Navigation control variables
////////////////////////////////////////////////////////////////////////////////
// The instantaneous desired bank angle.  Hundredths of a degree
static int32_t nav_roll_cd;

// The instantaneous desired pitch angle.  Hundredths of a degree
static int32_t nav_pitch_cd;

////////////////////////////////////////////////////////////////////////////////
// Mission library
////////////////////////////////////////////////////////////////////////////////
// forward declations needed for functions with : in arguments
static bool verify_command_callback(const AP_Mission::Mission_Command &cmd);
static bool start_command_callback(const AP_Mission::Mission_Command &cmd);
AP_Mission mission(ahrs, 
                   &start_command_callback, 
                   &verify_command_callback, 
                   &exit_mission_callback);

////////////////////////////////////////////////////////////////////////////////
// terrain handling
#if AP_TERRAIN_AVAILABLE
AP_Terrain terrain(ahrs, mission, rally);
#endif

////////////////////////////////////////////////////////////////////////////////
// Outback Challenge Failsafe Support
////////////////////////////////////////////////////////////////////////////////
#if OBC_FAILSAFE == ENABLED
APM_OBC obc(mission, barometer, gps, rcmap);
#endif

////////////////////////////////////////////////////////////////////////////////
// Waypoint distances
////////////////////////////////////////////////////////////////////////////////
// Distance between plane and next waypoint.  Meters
static uint32_t wp_distance;

// Distance between previous and next waypoint.  Meters
static uint32_t wp_totalDistance;

/*
  meta data to support counting the number of circles in a loiter
 */
static struct {
    // previous target bearing, used to update sum_cd
    int32_t old_target_bearing_cd;

    // Total desired rotation in a loiter.  Used for Loiter Turns commands. 
    int32_t total_cd;

    // total angle completed in the loiter so far
    int32_t sum_cd;

	// Direction for loiter. 1 for clockwise, -1 for counter-clockwise
    int8_t direction;

	// start time of the loiter.  Milliseconds.
    uint32_t start_time_ms;

	// The amount of time we should stay in a loiter for the Loiter Time command.  Milliseconds.
    uint32_t time_max_ms;
} loiter;


////////////////////////////////////////////////////////////////////////////////
// Conditional command
////////////////////////////////////////////////////////////////////////////////
// A value used in condition commands (eg delay, change alt, etc.)
// For example in a change altitude command, it is the altitude to change to.
static int32_t condition_value;
// A starting value used to check the status of a conditional command.
// For example in a delay command the condition_start records that start time for the delay
static uint32_t condition_start;
// A value used in condition commands.  For example the rate at which to change altitude.
static int16_t condition_rate;

////////////////////////////////////////////////////////////////////////////////
// 3D Location vectors
// Location structure defined in AP_Common
////////////////////////////////////////////////////////////////////////////////
// reference to AHRS home
static const struct Location &home = ahrs.get_home();

// Flag for if we have g_gps lock and have set the home location in AHRS
static bool home_is_set;
// The location of the previous waypoint.  Used for track following and altitude ramp calculations
static Location prev_WP_loc;
// The plane's current location
static struct   Location current_loc;
// The location of the current/active waypoint.  Used for altitude ramp, track following and loiter calculations.
static Location next_WP_loc;
// The location of the active waypoint in Guided mode.
static struct Location guided_WP_loc;
// special purpose command used only after mission completed to return vehicle to home or rally point
static struct AP_Mission::Mission_Command auto_rtl_command;

////////////////////////////////////////////////////////////////////////////////
// Altitude control
static struct {
    // target altitude above sea level in cm. Used for barometric
    // altitude navigation
    int32_t amsl_cm;

    // Altitude difference between previous and current waypoint in
    // centimeters. Used for glide slope handling
    int32_t offset_cm;

#if AP_TERRAIN_AVAILABLE
    // are we trying to follow terrain?
    bool terrain_following;

    // target altitude above terrain in cm, valid if terrain_following
    // is set
    int32_t terrain_alt_cm;

    // lookahead value for height error reporting
    float lookahead;
#endif
} target_altitude;

////////////////////////////////////////////////////////////////////////////////
// INS variables
////////////////////////////////////////////////////////////////////////////////
// The main loop execution time.  Seconds
//This is the time between calls to the DCM algorithm and is the Integration time for the gyros.
static float G_Dt                                               = 0.02f;

////////////////////////////////////////////////////////////////////////////////
// Performance monitoring
////////////////////////////////////////////////////////////////////////////////
// Timer used to accrue data and trigger recording of the performanc monitoring log message
static uint32_t perf_mon_timer;
// The maximum main loop execution time recorded in the current performance monitoring interval
static uint32_t G_Dt_max = 0;

////////////////////////////////////////////////////////////////////////////////
// System Timers
////////////////////////////////////////////////////////////////////////////////
// Time in microseconds of start of main control loop
static uint32_t fast_loopTimer_us;

// Number of milliseconds used in last main loop cycle
static uint32_t delta_us_fast_loop;

// Counter of main loop executions.  Used for performance monitoring and failsafe processing
static uint16_t mainLoop_count;

// Camera/Antenna mount tracking and stabilisation stuff
// --------------------------------------
#if MOUNT == ENABLED
// current_loc uses the baro/gps soloution for altitude rather than gps only.
// mabe one could use current_loc for lat/lon too and eliminate g_gps alltogether?
static AP_Mount camera_mount(&current_loc, ahrs, 0);
#endif

#if MOUNT2 == ENABLED
// current_loc uses the baro/gps soloution for altitude rather than gps only.
// mabe one could use current_loc for lat/lon too and eliminate g_gps alltogether?
static AP_Mount camera_mount2(&current_loc, ahrs, 1);
#endif

////////////////////////////////////////////////////////////////////////////////
// Arming/Disarming mangement class
////////////////////////////////////////////////////////////////////////////////
static AP_Arming arming(ahrs, barometer, compass, home_is_set, gcs_send_text_P);

////////////////////////////////////////////////////////////////////////////////
// Top-level logic
////////////////////////////////////////////////////////////////////////////////

/*
  scheduler table - all regular tasks are listed here, along with how
  often they should be called (in 20ms units) and the maximum time
  they are expected to take (in microseconds)
 */
static const AP_Scheduler::Task scheduler_tasks[] PROGMEM = {
    { read_radio,             1,    700 }, // 0
    { check_short_failsafe,   1,   1000 },
    { ahrs_update,            1,   6400 },
    { update_speed_height,    1,   1600 },
    { update_flight_mode,     1,   1400 },// 1,1400
    { stabilize,              1,   3500 },
    { set_servos,             1,   1600 },
    { read_control_switch,    7,   1000 },
    { gcs_retry_deferred,     1,   1000 },
    { update_GPS_50Hz,        1,   2500 },
    { update_GPS_10Hz,        5,   2500 }, // 10
    { navigate,               5,   3000 },
    { update_compass,         5,   1200 },
    { read_airspeed,          5,   1200 },
    { update_alt,             5,   3400 },
    { adjust_altitude_target, 5,   1000 },
    { obc_fs_check,           5,   1000 },
    { gcs_update,             1,   1700 },
    { gcs_data_stream_send,   1,   3000 },
    { update_events,		  1,   1500 }, // 20
    { check_usb_mux,          5,    300 },
    { read_battery,           5,   1000 },
    { compass_accumulate,     1,   1500 },
    { barometer_accumulate,   1,    900 },
    { update_notify,          1,    300 },
    { read_rangefinder,       1,    500 },
    { one_second_loop,       50,   1000 },
    { check_long_failsafe,   15,   1000 },
    { read_receiver_rssi,     5,   1000 },
    { airspeed_ratio_update, 50,   1000 }, // 30
    { update_mount,           1,   1500 },
    { log_perf_info,        500,   1000 },
    { compass_save,        3000,   2500 },
    { update_logging1,        5,   1700 },
    { update_logging2,        5,   1700 },
#if FRSKY_TELEM_ENABLED == ENABLED
    { telemetry_send,        10,    100 },	
#endif
    { terrain_update,         5,    500 },
};

// setup the var_info table
AP_Param param_loader(var_info);

void setup() {
    cliSerial = hal.console;

    // load the default values of variables listed in var_info[]
    AP_Param::setup_sketch_defaults();

    AP_Notify::flags.failsafe_battery = false;

    notify.init(false);

    rssi_analog_source = hal.analogin->channel(ANALOG_INPUT_NONE);

    init_ardupilot();

    // initialise the main loop scheduler
    scheduler.init(&scheduler_tasks[0], sizeof(scheduler_tasks)/sizeof(scheduler_tasks[0]));
}

void loop()
{
    // wait for an INS sample
    if (!ins.wait_for_sample(1000)) {
        return;
    }
    uint32_t timer = hal.scheduler->micros();

    delta_us_fast_loop  = timer - fast_loopTimer_us;
    G_Dt                = delta_us_fast_loop * 1.0e-6f;
    fast_loopTimer_us   = timer;

    if (delta_us_fast_loop > G_Dt_max)
        G_Dt_max = delta_us_fast_loop;

    mainLoop_count++;

    // tell the scheduler one tick has passed
    scheduler.tick();

    // run all the tasks that are due to run. Note that we only
    // have to call this once per loop, as the tasks are scheduled
    // in multiples of the main loop tick. So if they don't run on
    // the first call to the scheduler they won't run on a later
    // call until scheduler.tick() is called again
    uint32_t remaining = (timer + 20000) - hal.scheduler->micros();
    if (remaining > 19500) {
        remaining = 19500;
    }
    scheduler.run(remaining);
}

// update AHRS system
static void ahrs_update()
{
    ahrs.set_armed(arming.is_armed() && 
                   hal.util->safety_switch_state() != AP_HAL::Util::SAFETY_DISARMED);

#if HIL_MODE != HIL_MODE_DISABLED
    // update hil before AHRS update
    gcs_update();
#endif

    ahrs.update();

    if (should_log(MASK_LOG_ATTITUDE_FAST)) {
        Log_Write_Attitude();
    }

    if (should_log(MASK_LOG_IMU))
        Log_Write_IMU();

    // calculate a scaled roll limit based on current pitch
    roll_limit_cd = g.roll_limit_cd * cosf(ahrs.pitch);
    pitch_limit_min_cd = aparm.pitch_limit_min_cd * fabsf(cosf(ahrs.roll));

    // updated the summed gyro used for ground steering and
    // auto-takeoff. Dot product of DCM.c with gyro vector gives earth
    // frame yaw rate
    steer_state.locked_course_err += ahrs.get_yaw_rate_earth() * G_Dt;
    steer_state.locked_course_err = wrap_PI(steer_state.locked_course_err);
}

/*
  update 50Hz speed/height controller
 */
static void update_speed_height(void)
{
    if (auto_throttle_mode) {
	    // Call TECS 50Hz update. Note that we call this regardless of
	    // throttle suppressed, as this needs to be running for
	    // takeoff detection
        SpdHgt_Controller->update_50hz(relative_altitude());
    }
}


/*
  update camera mount
 */
static void update_mount(void)
{
#if MOUNT == ENABLED
    camera_mount.update_mount_position();
#endif

#if MOUNT2 == ENABLED
    camera_mount2.update_mount_position();
#endif

#if CAMERA == ENABLED
    camera.trigger_pic_cleanup();
#endif
}

/*
  read and update compass
 */
static void update_compass(void)
{
    if (g.compass_enabled && compass.read()) {
        ahrs.set_compass(&compass);
        compass.learn_offsets();
        if (should_log(MASK_LOG_COMPASS)) {
            Log_Write_Compass();
        }
    } else {
        ahrs.set_compass(NULL);
    }
}

/*
  if the compass is enabled then try to accumulate a reading
 */
static void compass_accumulate(void)
{
    if (g.compass_enabled) {
        compass.accumulate();
    }    
}

/*
  try to accumulate a baro reading
 */
static void barometer_accumulate(void)
{
    barometer.accumulate();
}

/*
  do 10Hz logging
 */
static void update_logging1(void)
{
    if (should_log(MASK_LOG_ATTITUDE_MED) && !should_log(MASK_LOG_ATTITUDE_FAST)) {
        Log_Write_Attitude();
    }

    if (should_log(MASK_LOG_ATTITUDE_MED) && !should_log(MASK_LOG_IMU))
        Log_Write_IMU();
}

/*
  do 10Hz logging - part2
 */
static void update_logging2(void)
{
    if (should_log(MASK_LOG_CTUN))
        Log_Write_Control_Tuning();
    
    if (should_log(MASK_LOG_NTUN))
        Log_Write_Nav_Tuning();

    if (should_log(MASK_LOG_RC))
        Log_Write_RC();
}


/*
  check for OBC failsafe check
 */
static void obc_fs_check(void)
{
#if OBC_FAILSAFE == ENABLED
    // perform OBC failsafe checks
    obc.check(OBC_MODE(control_mode), failsafe.last_heartbeat_ms, geofence_breached(), failsafe.last_valid_rc_ms);
#endif
}


/*
  update aux servo mappings
 */
static void update_aux(void)
{
    RC_Channel_aux::enable_aux_servos();

#if MOUNT == ENABLED
        camera_mount.update_mount_type();
#endif
#if MOUNT2 == ENABLED
        camera_mount2.update_mount_type();
#endif
}

static void one_second_loop()
{
    if (should_log(MASK_LOG_CURRENT))
        Log_Write_Current();

    // send a heartbeat
    gcs_send_message(MSG_HEARTBEAT);

    // make it possible to change control channel ordering at runtime
    set_control_channels();

    // make it possible to change orientation at runtime
    ahrs.set_orientation();

    // sync MAVLink system ID
    mavlink_system.sysid = g.sysid_this_mav;

    update_aux();

    // update notify flags
    AP_Notify::flags.pre_arm_check = arming.pre_arm_checks(false);
    AP_Notify::flags.armed = arming.is_armed() || arming.arming_required() == AP_Arming::NO;

#if AP_TERRAIN_AVAILABLE
    if (should_log(MASK_LOG_GPS)) {
        terrain.log_terrain_data(DataFlash);
    }
#endif
}

static void log_perf_info()
{
    if (scheduler.debug() != 0) {
        gcs_send_text_fmt(PSTR("G_Dt_max=%lu\n"), (unsigned long)G_Dt_max);
    }
    if (should_log(MASK_LOG_PM))
        Log_Write_Performance();
    G_Dt_max = 0;
    resetPerfData();
}

static void compass_save()
{
    if (g.compass_enabled) {
        compass.save_offsets();
    }
}

static void terrain_update(void)
{
#if AP_TERRAIN_AVAILABLE
    terrain.update();
#endif
}

/*
  once a second update the airspeed calibration ratio
 */
static void airspeed_ratio_update(void)
{
    if (!airspeed.enabled() ||
        gps.status() < AP_GPS::GPS_OK_FIX_3D ||
        gps.ground_speed() < 4) {
        // don't calibrate when not moving
        return;        
    }
    if (airspeed.get_airspeed() < aparm.airspeed_min && 
        gps.ground_speed() < (uint32_t)aparm.airspeed_min) {
        // don't calibrate when flying below the minimum airspeed. We
        // check both airspeed and ground speed to catch cases where
        // the airspeed ratio is way too low, which could lead to it
        // never coming up again
        return;
    }
    if (abs(ahrs.roll_sensor) > roll_limit_cd ||
        ahrs.pitch_sensor > aparm.pitch_limit_max_cd ||
        ahrs.pitch_sensor < pitch_limit_min_cd) {
        // don't calibrate when going beyond normal flight envelope
        return;
    }
    const Vector3f &vg = gps.velocity();
    airspeed.update_calibration(vg);
    gcs_send_airspeed_calibration(vg);
}


/*
  read the GPS and update position
 */
static void update_GPS_50Hz(void)
{
    static uint32_t last_gps_reading[GPS_MAX_INSTANCES];
    gps.update();

    for (uint8_t i=0; i<gps.num_sensors(); i++) {
        if (gps.last_message_time_ms(i) != last_gps_reading[i]) {
            last_gps_reading[i] = gps.last_message_time_ms(i);
            if (should_log(MASK_LOG_GPS)) {
                Log_Write_GPS(i);
            }
        }
    }
}

/*
  read update GPS position - 10Hz update
 */
static void update_GPS_10Hz(void)
{
    // get position from AHRS
    have_position = ahrs.get_position(current_loc);

    static uint32_t last_gps_msg_ms;
    if (gps.last_message_time_ms() != last_gps_msg_ms && gps.status() >= AP_GPS::GPS_OK_FIX_3D) {
        last_gps_msg_ms = gps.last_message_time_ms();

        if (ground_start_count > 1) {
            ground_start_count--;
        } else if (ground_start_count == 1) {
            // We countdown N number of good GPS fixes
            // so that the altitude is more accurate
            // -------------------------------------
            if (current_loc.lat == 0) {
                ground_start_count = 5;

            } else {
                init_home();

                // set system clock for log timestamps
                hal.util->set_system_clock(gps.time_epoch_usec());

                if (g.compass_enabled) {
                    // Set compass declination automatically
                    const Location &loc = gps.location();
                    compass.set_initial_location(loc.lat, loc.lng);
                }
                ground_start_count = 0;
            }
        }

        // see if we've breached the geo-fence
        geofence_check(false);

#if CAMERA == ENABLED
        if (camera.update_location(current_loc) == true) {
            do_take_picture();
        }
#endif        

        if (!ahrs.get_armed()) {
            update_home();
        }

        // update wind estimate
        ahrs.estimate_wind();
    }

    calc_gndspeed_undershoot();
}

/*
  main handling for AUTO mode
 */
static void handle_auto_mode(void)
{
    uint8_t nav_cmd_id;

    // we should be either running a mission or RTLing home
    if (mission.state() == AP_Mission::MISSION_RUNNING) {
        nav_cmd_id = mission.get_current_nav_cmd().id;
    }else{
        nav_cmd_id = auto_rtl_command.id;
    }

    switch(nav_cmd_id) {
    case MAV_CMD_NAV_TAKEOFF:
        takeoff_calc_roll();
        takeoff_calc_pitch();
        
        // max throttle for takeoff
        channel_throttle->servo_out = takeoff_throttle();
        break;

    case MAV_CMD_NAV_LAND:
        calc_nav_roll();
        calc_nav_pitch();
        
        if (auto_state.land_complete) {
            // during final approach constrain roll to the range
            // allowed for level flight
            nav_roll_cd = constrain_int32(nav_roll_cd, -g.level_roll_limit*100UL, g.level_roll_limit*100UL);
        } else {
            if (!airspeed.use()) {
                // when not under airspeed control, don't allow
                // down pitch in landing
                nav_pitch_cd = constrain_int32(nav_pitch_cd, 0, nav_pitch_cd);
            }
        }
        calc_throttle();
        
        if (auto_state.land_complete) {
            // we are in the final stage of a landing - force
            // zero throttle
            channel_throttle->servo_out = 0;
        }
        break;
        
    default:
        // we are doing normal AUTO flight, the special cases
        // are for takeoff and landing
        steer_state.hold_course_cd = -1;
        auto_state.land_complete = false;
        auto_state.land_sink_rate = 0;
        calc_nav_roll();
        calc_nav_pitch();
        calc_throttle();
        break;
    }
}

/*
  main flight mode dependent update code 
 */
// ASEN5519 where we're stitching /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static void update_flight_mode(void)
{
    enum FlightMode effective_mode = control_mode;
    if (control_mode == AUTO && g.auto_fbw_steer) {
        effective_mode = FLY_BY_WIRE_A;
    }

    if (effective_mode != AUTO) {
        // hold_course is only used in takeoff and landing
        steer_state.hold_course_cd = -1;
    }

    switch (effective_mode) 
    {
    case AUTO:
        handle_auto_mode();
        break;

    case RTL:
        calc_nav_pitch();
        calc_nav_roll();
        channel_throttle->servo_out = 0;//ASEN5519         
        break;
    case LOITER:
    case GUIDED:
        calc_nav_roll();
        calc_nav_pitch();
        calc_throttle();
        break;
    case TRAINING: {
        training_manual_roll = false;
        training_manual_pitch = false;
        
        // if the roll is past the set roll limit, then
        // we set target roll to the limit
        if (ahrs.roll_sensor >= roll_limit_cd) {
            nav_roll_cd = roll_limit_cd;
        } else if (ahrs.roll_sensor <= -roll_limit_cd) {
            nav_roll_cd = -roll_limit_cd;                
        } else {
            training_manual_roll = true;
            nav_roll_cd = 0;
        }
        
        // if the pitch is past the set pitch limits, then
        // we set target pitch to the limit
        if (ahrs.pitch_sensor >= aparm.pitch_limit_max_cd) {
            nav_pitch_cd = aparm.pitch_limit_max_cd;
        } else if (ahrs.pitch_sensor <= pitch_limit_min_cd) {
            nav_pitch_cd = pitch_limit_min_cd;
        } else {
            training_manual_pitch = true;
            nav_pitch_cd = 0;
        }
        if (fly_inverted()) {
            nav_pitch_cd = -nav_pitch_cd;
        }
        break;
    }

    case ACRO: {
        // handle locked/unlocked control
        if (acro_state.locked_roll) {
            nav_roll_cd = acro_state.locked_roll_err;
        } else {
            nav_roll_cd = ahrs.roll_sensor;
        }
        if (acro_state.locked_pitch) {
            nav_pitch_cd = acro_state.locked_pitch_cd;
        } else {
            nav_pitch_cd = ahrs.pitch_sensor;
        }
        break;
    }

    case AUTOTUNE:
    case FLY_BY_WIRE_A: {
        // ASEN5519 Alterations:        
        if (failsafe.ch3_failsafe && g.short_fs_action == 2) {
            // FBWA failsafe glide
            // ASEN5519 Alterations:
            calc_nav_pitch();
            calc_nav_roll();
            channel_throttle->servo_out = 0;//ASEN5519     
        }
        //Old_NED_pos[0] = Cur_NED_pos[0];
        //Old_NED_pos[1] = Cur_NED_pos[1];
        //Old_NED_pos[2] = Cur_NED_pos[2];
        
        gps_xyz(float(current_loc.lat*(0.0000001)),float(current_loc.lng*(0.0000001)),float(current_loc.alt*0.01),lat_origin,lon_origin,alt_origin,Cur_NED_pos);
        //if (Old_NED_pos[0] != Cur_NED_pos[0]){
        //cur_course = course_cal(Cur_NED_pos[0],Cur_NED_pos[1],Old_NED_pos[0],Old_NED_pos[1]);// cur n cur e old n old e
        //}        
        
        f_frew(float(Cur_NED_pos[0]),float(Cur_NED_pos[1]),float(Cur_NED_pos[2]),float(ahrs.yaw),frew_alg_com);
        //temp_pitch = pitch_ang_conv(frew_alg_com[2],frew_alg_com[0]);
        //temp_pitch = pitch_ang_conv(frew_alg_com[2],airspeed.get_airspeed());        
        temp_pitch = pitch_ang_conv(frew_alg_com[2],frew_alg_com[0]);
        temp_pitch = -1*temp_pitch;
        temp_roll = roll_ang_conv(frew_alg_com[1],frew_alg_com[0]);
        // Debug Statements        
        /*        
        count_val+=1;
        if (count_val==100){
        // Local XYZ pos prints
        hal.console->printf("Current X Val is: %f\r",Cur_NED_pos[0]);
        hal.console->printf("Current Y Val is: %f\r",Cur_NED_pos[1]);
        hal.console->printf("Current Z Val is: %f\r",Cur_NED_pos[2]);
        hal.console->printf("Current Chi Val is: %f\r",cur_course); 
        hal.console->printf("Current airspeed Val is: %f\r",airspeed.get_airspeed());      
        // Command Calc prints        
        hal.console->printf("Current Airspeed Com is: %f\r",frew_alg_com[0]);
        hal.console->printf("Current Chidot Com is: %f\r",frew_alg_com[1]);
        hal.console->printf("Current Climbrate Com is: %f\r",frew_alg_com[2]);
        // Roll and Pitch Prints        
        hal.console->printf("Current roll command is: %f\r",temp_roll);
        hal.console->printf("Current pitch command is: %f\r",temp_pitch);        
        count_val = 0;
        }*/
        calc_input_pitch(temp_pitch);
        calc_input_roll(temp_roll);
        calc_input_throttle(airspeed.get_airspeed(), frew_alg_com[0]);        
        //calc_throttle();
        break;
    }

    case FLY_BY_WIRE_B:
        // Thanks to Yury MonZon for the altitude limit code!
        nav_roll_cd = channel_roll->norm_input() * roll_limit_cd;
        update_fbwb_speed_height();
        break;
        
    case CRUISE:
        /*
          in CRUISE mode we use the navigation code to control
          roll when heading is locked. Heading becomes unlocked on
          any aileron or rudder input
        */
        if ((channel_roll->control_in != 0 ||
             channel_rudder->control_in != 0)) {                
            cruise_state.locked_heading = false;
            cruise_state.lock_timer_ms = 0;
        }                 
        
        if (!cruise_state.locked_heading) {
            nav_roll_cd = channel_roll->norm_input() * roll_limit_cd;
        } else {
            calc_nav_roll();
        }
        update_fbwb_speed_height();
        break;
        
    case STABILIZE:
        nav_roll_cd        = 0;
        nav_pitch_cd       = 0;
        // throttle is passthrough
        break;
        
    case CIRCLE:
        // we have no GPS installed and have lost radio contact
        // or we just want to fly around in a gentle circle w/o GPS,
        // holding altitude at the altitude we set when we
        // switched into the mode
        nav_roll_cd  = roll_limit_cd / 3;
        calc_nav_pitch();
        calc_throttle();
        break;

    case MANUAL:
        // servo_out is for Sim control only
        // ---------------------------------
        channel_roll->servo_out = channel_roll->pwm_to_angle();
        channel_pitch->servo_out = channel_pitch->pwm_to_angle();
        steering_control.steering = steering_control.rudder = channel_rudder->pwm_to_angle();
        break;
        //roll: -13788.000,  pitch: -13698.000,   thr: 0.000, rud: -13742.000
        
    case INITIALISING:
        // handled elsewhere
        break;
    }
}

static void update_navigation()
{
    // wp_distance is in ACTUAL meters, not the *100 meters we get from the GPS
    // ------------------------------------------------------------------------

    // distance and bearing calcs only
    switch(control_mode) {
    case AUTO:
        update_commands();
        break;
            
    case LOITER:
    case RTL:
    case GUIDED:
        // allow loiter direction to be changed in flight
        if (g.loiter_radius < 0) {
            loiter.direction = -1;
        } else {
            loiter.direction = 1;
        }
        update_loiter();
        break;

    case CRUISE:
        update_cruise();
        break;

    case MANUAL:
    case STABILIZE:
    case TRAINING:
    case INITIALISING:
    case ACRO:
    case FLY_BY_WIRE_A:
    case AUTOTUNE:
    case FLY_BY_WIRE_B:
    case CIRCLE:
        // nothing to do
        break;
    }
}

/*
  set the flight stage
 */
static void set_flight_stage(AP_SpdHgtControl::FlightStage fs) 
{
    //if just now entering land flight stage
    if (fs == AP_SpdHgtControl::FLIGHT_LAND_APPROACH &&
        flight_stage != AP_SpdHgtControl::FLIGHT_LAND_APPROACH) {

#if GEOFENCE_ENABLED == ENABLED 
        if (g.fence_autoenable == 1) {
            if (! geofence_set_enabled(false, AUTO_TOGGLED)) {
                gcs_send_text_P(SEVERITY_HIGH, PSTR("Disable fence failed (autodisable)"));
            } else {
                gcs_send_text_P(SEVERITY_HIGH, PSTR("Fence disabled (autodisable)"));
            }
        }
#endif
    }
    
    flight_stage = fs;
}

static void update_alt()
{
    barometer.read();
    if (should_log(MASK_LOG_IMU)) {
        Log_Write_Baro();
    }

    geofence_check(true);

    update_flight_stage();
}

/*
  recalculate the flight_stage
 */
static void update_flight_stage(void)
{
    // Update the speed & height controller states
    if (auto_throttle_mode && !throttle_suppressed) {        
        if (control_mode==AUTO) {
            if (auto_state.takeoff_complete == false) {
                set_flight_stage(AP_SpdHgtControl::FLIGHT_TAKEOFF);
            } else if (mission.get_current_nav_cmd().id == MAV_CMD_NAV_LAND && 
                       auto_state.land_complete == true) {
                set_flight_stage(AP_SpdHgtControl::FLIGHT_LAND_FINAL);
            } else if (mission.get_current_nav_cmd().id == MAV_CMD_NAV_LAND) {
                set_flight_stage(AP_SpdHgtControl::FLIGHT_LAND_APPROACH); 
            } else {
                set_flight_stage(AP_SpdHgtControl::FLIGHT_NORMAL);
            }
        } else {
            set_flight_stage(AP_SpdHgtControl::FLIGHT_NORMAL);
        }

        SpdHgt_Controller->update_pitch_throttle(relative_target_altitude_cm(),
                                                 target_airspeed_cm,
                                                 flight_stage,
                                                 auto_state.takeoff_pitch_cd,
                                                 throttle_nudge,
                                                 relative_altitude());
        if (should_log(MASK_LOG_TECS)) {
            Log_Write_TECS_Tuning();
        }
    }

    // tell AHRS the airspeed to true airspeed ratio
    airspeed.set_EAS2TAS(barometer.get_EAS2TAS());
}
///////////////////////////
// ASEN 5519 Function Calls
///////////////////////////
//GPS Code to local x,y,z
void gps_xyz (double lat_in, double lon_in, double alt_in, double lat_orig, double lon_orig, double alt_orig, double NED_pos[3])
{
  double lat_orig1 = lat_orig*PI_CU*deg_val_CU;// precompute 1/180 so no divide
  double lon_orig1 = lon_orig*PI_CU*deg_val_CU;
  double lat_in1 = lat_in*PI_CU*deg_val_CU;
  double lon_in1 = lon_in*PI_CU*deg_val_CU;
  double d_lon = lon_in1-lon_orig1;
  double d_lat = lat_in1-lat_orig1;
  double lat_m = (lat_in1+lat_orig1)/2;
  double z = -1*(alt_in-alt_orig); // -1 is to give us down
  //float x = r_earth*(cos(lat_orig1)*sin(lat_in1)-sin(lat_orig1)*cos(lat_in1)*cos(d_lon));  
  double x = r_earth_CU*d_lat;
  double y = r_earth_CU*(d_lon*cos(lat_m));
  NED_pos[0] = x;
  NED_pos[1] = y;
  NED_pos[2] = z;
}

// Frew Alg Call
void f_frew(float x, float y, float z, float chi,float frew_com[3])
{
	//Define all variables
	float r;		//Vehicle radius in polar coordinates
	float theta;	//Vehicle angle in polar coordinates
//	float z;		//Vehicle altitude in polar coordinates
	float k_r;		//Field radius gain
	float k_z;		//Field altitude gain
	float r_d;		//Desired radius at theta
	float z_d;		//Desired altitude at theta
	float r_d_prime;//Derivative of r w/r to theta at theta
	float z_d_prime;//Derivative or z w/r to theta at theta
	float rho;		//Parametric coordinate system radius
	//float phi;		//Parametric coordinate system angle
	float zeta;		//Parametric coordinate system altitude
	float v1_1;		//Unscaled velocity
	float v1_2;		//Unscaled velocity
	float v1_3;		//Unscaled velocity
	float v_desired;//Desired airspeed
	float alpha;	//Normalization constant for airspeed
	float v_r;		//Desired radial velocity
	float v_theta;	//Desired tangential velocity
	float v_z;		//Desired climb rate
	float v_x;		//Inertial x velocity desired
	float v_y;		//Inertial y velocity desired
	float delta_chi;//Error in heading
    float delta_chi_1;//Error in heading
    float delta_chi_2;//Error in heading
    float delta_chi_3;//Error in heading
	//Calculate cylindrical coordinates of vehicles
	r = pow(pow(x,2) + pow(y,2),.5);
	theta = atan2(y,x);
	//z = z;

	//Set vector field gains
	k_r = 1000;//100
	k_z = 5000;//500

	//Calculate desired radius and altitude and derivatives at theta
	r_d = a_r_0 + a_r_1*cos(theta*w_r) + b_r_1*sin(theta*w_r) +
	               a_r_2*cos(2*theta*w_r) + b_r_2*sin(2*theta*w_r) + a_r_3*cos(3*theta*w_r) + b_r_3*sin(3*theta*w_r) +
	               a_r_4*cos(4*theta*w_r) + b_r_4*sin(4*theta*w_r) + a_r_5*cos(5*theta*w_r) + b_r_5*sin(5*theta*w_r) +
	               a_r_6*cos(6*theta*w_r) + b_r_6*sin(6*theta*w_r) + a_r_7*cos(7*theta*w_r) + b_r_7*sin(7*theta*w_r) +
	               a_r_8*cos(8*theta*w_r) + b_r_8*sin(8*theta*w_r);
	z_d = a_z_0 + a_z_1*cos(theta*w_z) + b_z_1*sin(theta*w_z) +
	               a_z_2*cos(2*theta*w_z) + b_z_2*sin(2*theta*w_z) + a_z_3*cos(3*theta*w_z) + b_z_3*sin(3*theta*w_z) +
	               a_z_4*cos(4*theta*w_z) + b_z_4*sin(4*theta*w_z) + a_z_5*cos(5*theta*w_z) + b_z_5*sin(5*theta*w_z) +
	               a_z_6*cos(6*theta*w_z) + b_z_6*sin(6*theta*w_z) + a_z_7*cos(7*theta*w_z) + b_z_7*sin(7*theta*w_z) +
	               a_z_8*cos(8*theta*w_z) + b_z_8*sin(8*theta*w_z);
	r_d_prime = a_r_prime_0 + a_r_prime_1*cos(theta*w_r_prime) + b_r_prime_1*sin(theta*w_r_prime) +
	               a_r_prime_2*cos(2*theta*w_r_prime) + b_r_prime_2*sin(2*theta*w_r_prime) + a_r_prime_3*cos(3*theta*w_r_prime) + b_r_prime_3*sin(3*theta*w_r_prime) +
	               a_r_prime_4*cos(4*theta*w_r_prime) + b_r_prime_4*sin(4*theta*w_r_prime) + a_r_prime_5*cos(5*theta*w_r_prime) + b_r_prime_5*sin(5*theta*w_r_prime) +
	               a_r_prime_6*cos(6*theta*w_r_prime) + b_r_prime_6*sin(6*theta*w_r_prime) + a_r_prime_7*cos(7*theta*w_r_prime) + b_r_prime_7*sin(7*theta*w_r_prime) +
	               a_r_prime_8*cos(8*theta*w_r_prime) + b_r_prime_8*sin(8*theta*w_r_prime);
	z_d_prime = a_z_prime_0 + a_z_prime_1*cos(theta*w_z_prime) + b_z_prime_1*sin(theta*w_z_prime) +
	               a_z_prime_2*cos(2*theta*w_z_prime) + b_z_prime_2*sin(2*theta*w_z_prime) + a_z_prime_3*cos(3*theta*w_z_prime) + b_z_prime_3*sin(3*theta*w_z_prime) +
	               a_z_prime_4*cos(4*theta*w_z_prime) + b_z_prime_4*sin(4*theta*w_z_prime) + a_z_prime_5*cos(5*theta*w_z_prime) + b_z_prime_5*sin(5*theta*w_z_prime) +
	               a_z_prime_6*cos(6*theta*w_z_prime) + b_z_prime_6*sin(6*theta*w_z_prime) + a_z_prime_7*cos(7*theta*w_z_prime) + b_z_prime_7*sin(7*theta*w_z_prime) +
	               a_z_prime_8*cos(8*theta*w_z_prime) + b_z_prime_8*sin(8*theta*w_z_prime);

	//Calculate parametric coordinate system position               
	rho = r/r_d;
	//phi = theta; // Never used...
	zeta = z/z_d;
	//Calculate vector field value at current position
	v1_1 = -k_r*(rho - 1)*r_d + 2*r/r_d *r_d_prime;
	v1_2 = 2*r;
	v1_3 = 2*z/z_d * z_d_prime - k_z*(zeta - 1)*z_d;
	//Normalize to desired speed
	v_desired = 20;// originally 20, for a better tie that to the trim...
	alpha = v_desired/pow(pow(v1_1,2) + pow(v1_2,2) + pow(v1_3,2),0.5);
	v_r = alpha*v1_1;
	v_theta = alpha*v1_2;
	v_z = alpha*v1_3;
	//Calculate desired inertial velocity 
	v_x = v_r * cos(theta) - v_theta * sin(theta);
	v_y = v_r * sin(theta) + v_theta * cos(theta);
	//Find error in heading appropriately
	delta_chi_1 = atan2(v_y,v_x) - chi;
	delta_chi_2 = delta_chi_1 + 2*PI;
	delta_chi_3 = delta_chi_1 - 2*PI;

	delta_chi = delta_chi_1;
	if(abs(delta_chi_2) < abs(delta_chi))
	{
		delta_chi = delta_chi_2;
	}
	if(abs(delta_chi_3) < abs(delta_chi))
	{
		delta_chi = delta_chi_3;
	}

	// Assign chi dot gain
	float k_chi = .1;
	// Calculate commanded turn rate
	float chi_dot = k_chi*(delta_chi);
	// Set commands
	float u_v = v_desired;
	float u_chi_dot = chi_dot;
	float u_z = v_z;
	// Return command vector
	frew_com[0] = u_v;
	frew_com[1] = u_chi_dot;
	frew_com[2] = u_z;
}

//Pitch and Roll Conversions!
//Convert turn rate in rad/s to roll angle in centidegrees
float roll_ang_conv(float chidot, float com_airspeed) {
	float roll_ang = atan((com_airspeed*chidot)/GRAV_CU);
	return (roll_ang*180/PI_CU)*100;
}

//Convert climb rate in m/s to pitch angle in centidegrees
float pitch_ang_conv(float climbrate, float com_airspeed) {
	float pitch_ang = asin(climbrate/com_airspeed);
	return (pitch_ang*180.0/PI_CU)*100.0;
}

float course_cal(float cur_N, float cur_E, float old_N, float old_E){
        float delta_N =cur_N-old_N;
        float delta_E = cur_E-old_E;
        float course_ang_rad = atan2(delta_E,delta_N);
        return float(course_ang_rad);
}
///////////////////////////////
// End ASEN 5519 Function Calls
///////////////////////////////
AP_HAL_MAIN();
